
name: New Crossyroad Version

on:
  push:
  # workflow_dispatch:

env:
  YH_MYSQL_PASSWORD: "pass"
  YH_MYSQL_HOST: "mysql"
  # ECR_BACKEND_REPO: ${{ env.ECR_BACKEND_REPO }}
  # ECR_FRONTEND_REPO: ${{ env.ECR_FRONTEND_REPO }}

jobs:
  scm_checkout:
    runs-on: self-hosted
    steps:
    - name: checkout source code
      uses: actions/checkout@v4
    - name: check versions
      run: |
        docker version
        aws --version
        echo -e "$YOTPASS"
  
  testing:
    needs: [scm_checkout]
    runs-on: self-hosted
    steps:
    - name: build images
      run: |
        docker build -t crossy-backend ./app/
        docker build -t crossy-frontend ./nginx/

    - name: build test environment
      run: |
        docker compose down -v
        docker compose build
        docker compose up -d
    
    - name: E2E
      if: github.ref == 'refs/heads/master' || startsWith(github.ref, 'refs/heads/feature')
      run: |
        bash scripts/e2e.sh localhost 
        # $JENKINS_URL 
    
    - name: destroy test environment
      run: |
        docker compose down -v

  publish:
    needs: [testing]
    runs-on: self-hosted
    if: github.ref == 'refs/heads/master'
    steps:
    - name: tagging
      run: |
        git fetch --all --tags
        oldDIG=sh(returnStdout: true, script: 'git describe --tags | tr "-" "\n" | head -1 || echo 1.0.0').trim()
        newDIG=sh(returnStdout: true, script: "bash scripts/changeLastChar.sh $oldDIG").trim()
        git tag $newDIG
        git push --tags
        docker tag crossy-backend $ECR_BACKEND_REPO:$newDIG
        docker tag crossy-frontend $ECR_FRONTEND_REPO:$newDIG

  #   - name: publishing
  #     run: |
  #       docker.image("$ECR_BACKEND_REPO:$newDIG").push()
  #       docker.image("$ECR_FRONTEND_REPO:$newDIG").push()
  
  # deploy:
  #   needs: [publish]
  #   runs-on: self-hosted
  #   if: github.ref == 'refs/heads/master'
  #   steps:
  #   - name: deployment
  #     run: |
  #       git fetch --all --tags
  #       oldDIG=sh(returnStdout: true, script: 'git describe --tags | tr "-" "\n" | head -1 || echo 1.0.0').trim()
  #       newDIG=sh(returnStdout: true, script: "bash scripts/changeLastChar.sh $oldDIG").trim()
  #       git tag $newDIG
  #       git push --tags
  #       docker tag crossy-backend $ECR_BACKEND_REPO:$newDIG
  #       docker tag crossy-frontend $ECR_FRONTEND_REPO:$newDIG

  #   - name: publishing
  #     run: |
  #       docker.image("$ECR_BACKEND_REPO:$newDIG").push()
  #       docker.image("$ECR_FRONTEND_REPO:$newDIG").push()
  


# stage('Deploy'){
#   when { branch 'master' }
#   steps{
#       script{
#           withCredentials([gitUsernamePassword(credentialsId: "$GITHUB_CREDS", gitToolName: 'git-tool')]) {
#               sh "git clone $DEPLOY_REPO"
#               env.EMAIL=sh(returnStdout: true, script: 'git log --format="%ae" | head -1').trim()
#               dir('portfolio-charts') {
#                   sh "sed 's/tag: *.*.*/tag: $newDIG/g' application/values.yaml > ./application/newvalues.yaml"
#                   sh "rm application/values.yaml"
#                   sh "mv application/newvalues.yaml application/values.yaml"
#                   sh "git config --global user.email '$EMAIL'"
#                   sh "git config --global user.name 'Jenkins'"
#                   sh "git add application/values.yaml"
#                   sh "git commit -m 'changed image tag to $newDIG'"
#                   sh "git push origin master"
#               }
#           }
#       }
#   }
# }




  #     - name: get changed folders
  #       uses: Stockopedia/action-get-changed-files@v1
  #       id: get_changed_folders
  #       with:
  #         github-token: ${{ secrets.GITHUB_TOKEN }}
  #         ignore: ".github"
  #         foldersOnly: true # to only include folders in the output
  #         format: json # either json, csv or newline
  #   outputs:
  #     Folders: ${{ steps.get_changed_folders.outputs.changed }}


  # test_lambdas:
  #   needs: get_changed_sam
  #   runs-on: ubuntu-latest
  #   strategy:
  #     matrix:
  #       Folders: ${{ fromJSON(needs.get_changed_sam.outputs.Folders) }}
    
  #   steps:
  #     - name: checkout source code
  #       uses: actions/checkout@v4
      
  #     - name: setup sam
  #       uses: aws-actions/setup-sam@v2
  #       with:
  #         use-installer: true

  #     - name: build testing environment
  #       run: |
  #         cd ${{ matrix.Folders }}
  #         sam build
  #         sam local start-api &
  #         sleep 25
  #         bash tests.sh
  #         cd ..

  # update_lambdas:
  #   needs: [get_changed_sam, test_lambdas]
  #   runs-on: ubuntu-latest
  #   strategy:
  #     matrix:
  #       Folders: ${{ fromJSON(needs.get_changed_sam.outputs.Folders) }}

  #   steps:
  #     - name: checkout source code
  #       uses: actions/checkout@v4

  #     - name: setup dotnet6
  #       uses: actions/setup-dotnet@v3
  #       with:
  #         dotnet-version: '6.0.x'
  #     - run: dotnet tool install -g Amazon.Lambda.Tools
      
  #     - name: Configure AWS Credentials
  #       uses: aws-actions/configure-aws-credentials@v4
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         aws-region: ${{ secrets.AWS_REGION }}
      
  #     - name: deploy function
  #       run: |
  #         cd ${{ matrix.Folders }}/src
  #         FUNCTIONS=($(ls))
  #         for f in ${FUNCTIONS[@]}
  #         do
  #           cd $f
  #           dotnet lambda deploy-function
  #           dotnet lambda package
  #           aws s3 cp $(pwd)/bin/Release/net6.0/$f.zip s3://$S3_BUCKET/$f/
  #           cd ..
  #         done
      
  #     - name: slack notification
  #       uses: ./.github/actions/slack
  #       with:
  #         slack_webhook: ${{ secrets.SLACK_WEBHOOK }}
  #         result: ${{ job.status }}
  #         channel: $SLACK_CHANNEL
